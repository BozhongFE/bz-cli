#!/usr/bin/env node

// nodejs module
const fs = require('fs-extra');
const { resolve } = require('path');
const globby = require('globby');
const { isBinaryFileSync } = require('isbinaryfile');
// commander
const program = require('commander');
const inquirer = require('inquirer');
const ora = require('ora');
const git = require('download-git-repo');
const chalk = require('chalk');
const _ = require('lodash');
const Handlebars = require('handlebars');

// gulp module
const gulp = require('gulp');
const watch = require('gulp-watch');
const gulpif = require('gulp-if');
const header = require('gulp-header');
const less = require('gulp-less');
const rename = require('gulp-rename');
const cleanCSS = require('gulp-clean-css');
const autoprefixer = require('gulp-autoprefixer');
const base64 = require('gulp-base64');
// base module
const { getPackageSrc, exists, cwd, debounce, filters, matchs } = require('../libs/utils');
const { debug, info, error } = require('../libs/log');
const { getFile, readFiles, writeFileTree } = require('../libs/fs');
// global variable
const packageSrc = getPackageSrc();
const xpkg = getPackage();

// register handlebars helper
Handlebars.registerHelper('if_eq', function (a, b, opts) {
  return a === b
    ? opts.fn(this)
    : opts.inverse(this);
});
Handlebars.registerHelper('unless_eq', function (a, b, opts) {
  return a === b
    ? opts.inverse(this)
    : opts.fn(this);
});
Handlebars.registerHelper('if_or', function (a, b, opts) {
  return a || b
    ? opts.fn(this)
    : opts.inverse(this);
});
Handlebars.registerHelper('if_and', function (a, b, opts) {
  return a && b
    ? opts.fn(this)
    : opts.inverse(this);
});

// define command
program
  .usage('[options]')
  // .option('-p, --preset <presetName>', 'Skip prompts and use saved or remote preset')
  .parse(process.argv);

// console.log(xpkg);

const isVueCli3 = Boolean(xpkg.scripts && xpkg.scripts.serve && xpkg.scripts.serve.match(/vue-cli-service/));
if (!isVueCli3) {
  throw new Error('本项目不是用 vue-cli@3.x 搭建的项目，不能使用 bz vue');
}
// inquirer.prompt([{
//   type: 'confirm',
//   message: 'Target directory exists. Continue?',
//   name: 'power',
//   default: true,
// }]).then(answers => {
//   if (answers.power) {
//     run();
//   }
// });

const templatePath = program.args[0] || 'BozhongFE/vue-template'
run();

function run() {
  const uid = Math.random().toString(35).substr(2, 10);
  const tmpPath = `/tmp/dme-${uid}`;
  // is local
  if (fs.existsSync(templatePath)) {
    generate(templatePath, process.cwd(), function (err) {
      if (err) console.error(err)
      console.log('bz vue upgrade success')
    })
  } else {
    var spinner = ora(`Downloading ${templatePath}`);
    spinner.start()
    // return require('../lib/generate')(projectName, '/code/project/dme')
    git(templatePath, tmpPath, {}, function(err) {
      spinner.stop()
      if (err) {
        return console.error(chalk.red(err))
      }
      console.log(`download ${templatePath.split('/')[1]} success`)
      // process.on('exit', function () {
      //   rm('/tmp/dme-' + uid)
      // })
      generate(tmpPath, process.cwd(), err => {
        if (err) {
          err.check = err.path.replace(tmpPath, templatePath)
          console.error(err)
        } else
          console.log('bz vue upgrade success')
      })
      console.log('start1');
    })
  }
}

async function generate(tmp, dest, done) {
  build(tmp, dest, done);
}

async function build(tmp, dest, done) {
  const preset = getFile(resolve(tmp, 'preset.json'), true);
  const bzPreset = require(resolve(tmp, 'template.preset.js'));
  /**
   * template perset: filters
   */
  const files = await readFiles(resolve(tmp, 'template'));
  filters(files, bzPreset.template.filters, preset);
  const fileNames = Object.keys(files);
  // _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
  fileNames.forEach((key) => {
    if (typeof files[key] === 'string') {
      files[key] = Handlebars.compile(files[key])(preset);
    }
  });
  await writeFileTree(dest, files);
  /**
   * destination preset: removes
   */
  const removeFiles = await readFiles(dest, {
    hasContent: false,
  });
  matchs(removeFiles, bzPreset.destination.removes, preset);
  const removeFileNames = Object.keys(removeFiles);
  removeFileNames.forEach(fs.removeSync);
  /**
   * destination preset: transforms
   */
  const transformFiles = await readFiles(dest);
  matchs(transformFiles, bzPreset.destination.transforms, preset, false);
  const transformFileNames = Object.keys(transformFiles);
  transformFileNames.forEach((key) => {
    if (Object.prototype.toString.call(bzPreset.destination.transforms[key]) === '[object Function]') {
      transformFiles[key] = bzPreset.destination.transforms[key](transformFiles[key], _);
    }
  });
  await writeFileTree(dest, transformFiles);
}

function getPackage() {
  const xpkg = getFile(packageSrc, true);
  return xpkg;
}