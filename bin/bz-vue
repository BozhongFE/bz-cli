#!/usr/bin/env node

// nodejs module
const fs = require('fs-extra');
const path = require('path');
const globby = require('globby');
const { isBinaryFileSync } = require('isbinaryfile');
// commander
const program = require('commander');
const inquirer = require('inquirer');
const ora = require('ora');
const git = require('download-git-repo');
const chalk = require('chalk');
const _ = require('lodash');
const Handlebars = require('handlebars');
const rm = require('rimraf').sync;

// gulp module
const gulp = require('gulp');
const watch = require('gulp-watch');
const gulpif = require('gulp-if');
const header = require('gulp-header');
const less = require('gulp-less');
const rename = require('gulp-rename');
const cleanCSS = require('gulp-clean-css');
const autoprefixer = require('gulp-autoprefixer');
const base64 = require('gulp-base64');
// base module
const { getPackageSrc, exists, cwd, debounce, filters, matchs, isFunction } = require('../libs/utils');
const { debug, info, error } = require('../libs/log');
const { getFile, readFiles, writeFileTree } = require('../libs/fs');
// global variable
const packageSrc = getPackageSrc();
const xpkg = getPackage();

// register handlebars helper
Handlebars.registerHelper('if_eq', function (a, b, opts) {
  return a === b
    ? opts.fn(this)
    : opts.inverse(this);
});
Handlebars.registerHelper('unless_eq', function (a, b, opts) {
  return a === b
    ? opts.inverse(this)
    : opts.fn(this);
});
Handlebars.registerHelper('if_or', function (a, b, opts) {
  return a || b
    ? opts.fn(this)
    : opts.inverse(this);
});
Handlebars.registerHelper('if_and', function (a, b, opts) {
  return a && b
    ? opts.fn(this)
    : opts.inverse(this);
});

// define command
program
  .usage('[options]')
  // .option('-p, --preset <presetName>', 'Skip prompts and use saved or remote preset')
  .parse(process.argv);

// console.log(xpkg);

const isVueCli3 = Boolean(xpkg.scripts && xpkg.scripts.serve && xpkg.scripts.serve.match(/vue-cli-service/));
if (!isVueCli3) {
  throw new Error('本项目不是用 vue-cli@3.x 搭建的项目，不能使用 bz vue');
}

start();
async function start() {
  const isCoverage = await fileCoverage();
  if (isCoverage) {
    const tmp = await downloadTemplate();
    const answers = await appAsk(tmp);
    generate(tmp, answers);
  }
  // console.log(isCoverage);
  // fileCoverage(function() {
  //   downloadTemplate(function(tmp) {
  //     appAsk(tmp, function(preset) {
  //       console.log(preset);
  //     });
  //   });
  // });
}

/**
 * File Coverage
 */
async function fileCoverage(callback) {
  const answers = await inquirer.prompt([{
    type: 'confirm',
    message: 'Target directory exists. Continue?',
    name: 'power',
    default: true,
  }]);
  return answers.power;
}

/**
 * Download Template
 */
function downloadTemplate(callback) {
  const templatePath = program.args[0] || 'BozhongFE/vue-template';
  const uid = Math.random().toString(35).substr(2, 10);
  const tmpPath = `/tmp/bz-vue-template-${uid}`;
  // local reading
  if (fs.existsSync(templatePath)) {
    return templatePath
  }
  // remote download
  const spinner = ora(`Downloading ${templatePath}`);
  spinner.start();
  return new Promise(resolve => {
    git(templatePath, tmpPath, {}, (err) => {
      spinner.stop();
      if (err) {
        return console.error(chalk.red(err))
      }
      console.log(chalk.blue(`download ${templatePath} success`));
      process.on('exit', () => {
        rm(tmpPath);
      });
      resolve(tmpPath);
    })
  });
  
}

/**
 * Application Ask
 */
function appAsk(tmp) {
  const appPreset = require(path.resolve(tmp, 'app.preset.js'));
  return inquirer.prompt(appPreset.prompts);
}

/**
 * Build Template
 */
async function generate(tmp, answers) {
  const dest = process.cwd();
  let preset = getFile(path.resolve(tmp, 'preset.json'), true);
  const appPreset = require(path.resolve(tmp, 'app.preset.js'));
  /**
   * Upgrade Preset Data
   */
  Object.assign(preset, answers);
  if (isFunction(appPreset.presetTransform)) {
    preset = appPreset.presetTransform(preset, _) || preset;
  }
  
  /**
   * template perset: filters
   */
  const files = await readFiles(path.resolve(tmp, 'template'));
  filters(files, appPreset.template.filters, preset);
  const fileNames = Object.keys(files);
  fileNames.forEach((key) => {
    if (typeof files[key] === 'string') {
      files[key] = Handlebars.compile(files[key])(Object.assign({
        redirect: true,
      }, preset));
    }
  });
  await writeFileTree(dest, files);
  /**
   * destination preset: removes
   */
  const removeFiles = await readFiles(dest, {
    hasContent: false,
  });
  matchs(removeFiles, appPreset.destination.removes, preset);
  const removeFileNames = Object.keys(removeFiles);
  removeFileNames.forEach(fs.removeSync);
  /**
   * destination preset: transforms
   */
  const transformFiles = await readFiles(dest);
  matchs(transformFiles, appPreset.destination.transforms, preset, false);
  const transformFileNames = Object.keys(transformFiles);
  transformFileNames.forEach((key) => {
    if (isFunction(appPreset.destination.transforms[key])) {
      transformFiles[key] = appPreset.destination.transforms[key](transformFiles[key], preset, _);
    }
  });
  await writeFileTree(dest, transformFiles);
}

function getPackage() {
  const xpkg = getFile(packageSrc, true);
  return xpkg;
}