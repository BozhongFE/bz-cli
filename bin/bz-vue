#!/usr/bin/env node

// nodejs module
const fs = require('fs-extra');
const path = require('path');
// commander
const program = require('commander');
const inquirer = require('inquirer');
const ora = require('ora');
const git = require('download-git-repo');
const _ = require('lodash');
const Handlebars = require('handlebars');

// base module
const { getPackageSrc, filters, matchs, isFunction } = require('../libs/utils');
const { info, error } = require('../libs/log');
const { readFiles, writeFileTree } = require('../libs/fs');
// global variable
const packageSrc = getPackageSrc();
const xpkg = fs.readJsonSync(packageSrc);

// register handlebars helper
Handlebars.registerHelper('if_eq', function (a, b, opts) {
  return a === b
    ? opts.fn(this)
    : opts.inverse(this);
});
Handlebars.registerHelper('unless_eq', function (a, b, opts) {
  return a === b
    ? opts.inverse(this)
    : opts.fn(this);
});
Handlebars.registerHelper('if_or', function (a, b, opts) {
  return a || b
    ? opts.fn(this)
    : opts.inverse(this);
});
Handlebars.registerHelper('if_and', function (a, b, opts) {
  return a && b
    ? opts.fn(this)
    : opts.inverse(this);
});

// define command
program
  .usage('[options]')
  // .option('-p, --preset <presetName>', 'Skip prompts and use saved or remote preset')
  .parse(process.argv);

const isVueCli3 = Boolean(xpkg.scripts && xpkg.scripts.serve && xpkg.scripts.serve.match(/vue-cli-service/));
if (!isVueCli3) {
  throw new Error('本项目不是用 vue-cli@3.x 搭建的项目，不能使用 bz vue');
}

start();
async function start() {
  const isCoverage = await fileCoverage();
  if (isCoverage) {
    const tmp = await downloadTemplate();
    const answers = await appAsk(tmp);
    generate(tmp, answers);
  }
}

/**
 * File Coverage
 */
async function fileCoverage() {
  const answers = await inquirer.prompt([{
    type: 'confirm',
    message: 'Target directory exists. Continue（Suggest Backup）?',
    name: 'power',
    default: false,
  }]);
  return answers.power;
}

/**
 * Download Template
 */
function downloadTemplate() {
  const templatePath = program.args[0] || 'BozhongFE/vue-template';
  const uid = Math.random().toString(35).substr(2, 10);
  // local reading
  if (fs.existsSync(templatePath)) {
    return templatePath;
  }
  const tmpPath = `/tmp/bz-vue-template-${uid}`;
  // remote download
  const spinner = ora(`Downloading ${templatePath}`);
  spinner.start();
  return new Promise(resolve => {
    git(templatePath, tmpPath, {}, (err) => {
      spinner.stop();
      if (err) {
        return error(err);
      }
      info(`download ${templatePath} success`);
      process.on('exit', () => {
        if (fs.existsSync(tmpPath)) {
          fs.removeSync(tmpPath);
        }
      });
      resolve(tmpPath);
    });
  });
  
}

/**
 * Application Ask
 */
function appAsk(tmp) {
  const appPreset = require(path.resolve(tmp, 'app.preset.js'));
  return inquirer.prompt(appPreset.prompts);
}

/**
 * Build Template
 */
async function generate(tmp, answers) {
  const dest = process.cwd();
  let preset = fs.readJsonSync(path.resolve(tmp, 'preset.json'));
  const appPreset = require(path.resolve(tmp, 'app.preset.js'));
  /**
   * Upgrade Preset Data
   */
  Object.assign(preset, answers);
  if (isFunction(appPreset.presetTransform)) {
    preset = appPreset.presetTransform(preset, _) || preset;
  }
  
  /**
   * template perset: filters
   */
  const files = await readFiles(path.resolve(tmp, 'template'));
  filters(files, appPreset.template.filters, preset);
  const fileNames = Object.keys(files);
  fileNames.forEach((key) => {
    if (typeof files[key] === 'string') {
      files[key] = Handlebars.compile(files[key])(Object.assign({
        redirect: true,
      }, preset));
    }
  });
  await writeFileTree(dest, files);
  /**
   * destination preset: removes
   */
  const removeFiles = await readFiles(dest, {
    hasContent: false,
  });
  matchs(removeFiles, appPreset.destination.removes, preset);
  const removeFileNames = Object.keys(removeFiles);
  removeFileNames.filter(item => {
    if (fs.existsSync(item)) {
      return true;
    }
  });
  removeFileNames.map(fs.removeSync);
  /**
   * destination preset: transforms
   */
  const transformFiles = await readFiles(dest);
  matchs(transformFiles, appPreset.destination.transforms, preset, false);
  const transformFileNames = Object.keys(transformFiles);
  transformFileNames.forEach((key) => {
    if (isFunction(appPreset.destination.transforms[key])) {
      transformFiles[key] = appPreset.destination.transforms[key](transformFiles[key], preset, _);
    }
  });
  await writeFileTree(dest, transformFiles);
  /**
   * complete
   */
  if (isFunction(appPreset.complete)) {
    appPreset.complete(preset, _);
  }
}