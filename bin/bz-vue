#!/usr/bin/env node

// nodejs module
const { statSync, existsSync } = require('fs');
const { resolve } = require('path');
// commander
const program = require('commander');
const inquirer = require('inquirer');
const ora = require('ora');
const git = require('download-git-repo');
const chalk = require('chalk');
const metalsmith = require('metalsmith');
const metadata = require('metalsmith-metadata');
const layouts = require('metalsmith-layouts');
const _ = require('lodash');
const transformLodash = require('jstransformer')(require('jstransformer-lodash'));

// gulp module
const gulp = require('gulp');
const watch = require('gulp-watch');
const gulpif = require('gulp-if');
const header = require('gulp-header');
const less = require('gulp-less');
const rename = require('gulp-rename');
const cleanCSS = require('gulp-clean-css');
const autoprefixer = require('gulp-autoprefixer');
const base64 = require('gulp-base64');
// base module
const { getPackageSrc, exists, cwd, debounce } = require('../libs/utils');
const { debug, info, error } = require('../libs/log');
const { getFile, readFiles, writeFileTree } = require('../libs/fs');
// global variable
const packageSrc = getPackageSrc();
const xpkg = getPackage();

// define command
program
  .usage('[options]')
  // .option('-p, --preset <presetName>', 'Skip prompts and use saved or remote preset')
  .parse(process.argv);

// console.log(xpkg);

// inquirer.prompt([{
//   type: 'confirm',
//   message: 'Target directory exists. Continue?',
//   name: 'power',
//   default: true,
// }]).then(answers => {
//   if (answers.power) {
//     const isVueCli3 = Boolean(xpkg.scripts && xpkg.scripts.serve && xpkg.scripts.serve.match(/vue-cli-service/));
//     if (!isVueCli3) {
//       throw new Error('本项目不是用 vue-cli@3.x 搭建的项目，不能使用 bz vue');
//     }
//     run();
//   }
// });

const templatePath = program.args[0] || 'BozhongFE/vue-template'
run();

function run() {
  const uid = Math.random().toString(35).substr(2, 10);
  const tmpPath = `/tmp/dme-${uid}`;
  // is local
  if (existsSync(templatePath)) {
    generate(templatePath, process.cwd(), function (err) {
      if (err) console.error(err)
      console.log('bz vue upgrade success')
    })
  } else {
    var spinner = ora(`Downloading ${templatePath}`);
    spinner.start()
    // return require('../lib/generate')(projectName, '/code/project/dme')
    git(templatePath, tmpPath, {}, function(err) {
      spinner.stop()
      if (err) {
        return console.error(chalk.red(err))
      }
      console.log(`download ${templatePath.split('/')[1]} success`)
      // process.on('exit', function () {
      //   rm('/tmp/dme-' + uid)
      // })
      generate(tmpPath, process.cwd(), err => {
        if (err) {
          err.check = err.path.replace(tmpPath, templatePath)
          console.error(err)
        } else
          console.log('bz vue upgrade success')
      })
      console.log('start1');
    })
  }
}

async function generate(tmp, dest, done) {
  const preset = getFile(resolve(tmp, 'preset.json'), true);
  console.log(tmp, dest);
  const root = resolve(tmp, 'template/src/router');
  const files = await readFiles(root);
  for (const key in files) {
    files[key] = _.template(files[key])(preset);
  }
  await writeFileTree(resolve(dest, 'src/router'), files);
  // console.log(preset);
  // const arr = [new Promise((resolve, reject) => {
  //   metalsmith(tmp)
  //     // .use(metadata(preset))
  //     .use(update1())
  //     // .use(update())
  //     .source('./template/src/router')
  //     .destination(resolve(dest, 'src/router'))
  //     .build(done);
  // })];
  // Promise.all(arr).then(done);
}

function update1() {
  console.log(3331);
  return function (files, metalsmith, done) {
    console.log(3132312);
    var metaJson = metalsmith.metadata()
    console.log(333, files, metaJson);
    done(34);
    // require('./update')(files, metaJson, done)
  }
}
function update() {
  console.log(89);
  return function (files, metalsmith, done) {
    var metaJson = metalsmith.metadata()
    console.log(files, metaJson);
    done();
    // require('./update')(files, metaJson, done)
  }
}

function getPackage() {
  const xpkg = getFile(packageSrc, true);
  return xpkg;
}