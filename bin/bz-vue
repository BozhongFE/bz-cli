#!/usr/bin/env node

// nodejs module
const fs = require('fs-extra');
const { resolve } = require('path');
const globby = require('globby');
const { isBinaryFileSync } = require('isbinaryfile');
// commander
const program = require('commander');
const inquirer = require('inquirer');
const ora = require('ora');
const git = require('download-git-repo');
const chalk = require('chalk');
const _ = require('lodash');

// gulp module
const gulp = require('gulp');
const watch = require('gulp-watch');
const gulpif = require('gulp-if');
const header = require('gulp-header');
const less = require('gulp-less');
const rename = require('gulp-rename');
const cleanCSS = require('gulp-clean-css');
const autoprefixer = require('gulp-autoprefixer');
const base64 = require('gulp-base64');
// base module
const { getPackageSrc, exists, cwd, debounce, filters, removes } = require('../libs/utils');
const { debug, info, error } = require('../libs/log');
const { getFile, readFiles, writeFileTree } = require('../libs/fs');
// global variable
const packageSrc = getPackageSrc();
const xpkg = getPackage();

// define command
program
  .usage('[options]')
  // .option('-p, --preset <presetName>', 'Skip prompts and use saved or remote preset')
  .parse(process.argv);

// console.log(xpkg);

// inquirer.prompt([{
//   type: 'confirm',
//   message: 'Target directory exists. Continue?',
//   name: 'power',
//   default: true,
// }]).then(answers => {
//   if (answers.power) {
//     const isVueCli3 = Boolean(xpkg.scripts && xpkg.scripts.serve && xpkg.scripts.serve.match(/vue-cli-service/));
//     if (!isVueCli3) {
//       throw new Error('本项目不是用 vue-cli@3.x 搭建的项目，不能使用 bz vue');
//     }
//     run();
//   }
// });

const templatePath = program.args[0] || 'BozhongFE/vue-template'
run();

function run() {
  const uid = Math.random().toString(35).substr(2, 10);
  const tmpPath = `/tmp/dme-${uid}`;
  // is local
  if (fs.existsSync(templatePath)) {
    generate(templatePath, process.cwd(), function (err) {
      if (err) console.error(err)
      console.log('bz vue upgrade success')
    })
  } else {
    var spinner = ora(`Downloading ${templatePath}`);
    spinner.start()
    // return require('../lib/generate')(projectName, '/code/project/dme')
    git(templatePath, tmpPath, {}, function(err) {
      spinner.stop()
      if (err) {
        return console.error(chalk.red(err))
      }
      console.log(`download ${templatePath.split('/')[1]} success`)
      // process.on('exit', function () {
      //   rm('/tmp/dme-' + uid)
      // })
      generate(tmpPath, process.cwd(), err => {
        if (err) {
          err.check = err.path.replace(tmpPath, templatePath)
          console.error(err)
        } else
          console.log('bz vue upgrade success')
      })
      console.log('start1');
    })
  }
}

async function generate(tmp, dest, done) {
  const preset = getFile(resolve(tmp, 'preset.json'), true);
  const bzPreset = getFile(resolve(tmp, 'bz.preset.json'), true);
  // copy tmp files to dest
  const files = await readFiles(resolve(tmp, 'template'));
  for (const file in files) {
    const name = resolve(resolve(tmp, 'template'), file);
    if (isBinaryFileSync(name)) {
      console.log(files[file]);
    }
  }
  // console.log(Object.keys(files));
  filters(files, bzPreset.template.filters, preset);
  const fileNames = Object.keys(files);
  fileNames.forEach((key) => {
    files[key] = _.template(files[key])(preset);
  });
  await writeFileTree(dest, files);
  // remove files from dest
  const removeFiles = await readFiles(dest, {
    hasContent: false,
  });
  removes(removeFiles, bzPreset.destination.removes, preset);
  const removeFileNames = Object.keys(removeFiles);
  removeFileNames.forEach(fs.removeSync);
}

function getPackage() {
  const xpkg = getFile(packageSrc, true);
  return xpkg;
}